<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>TaxIT 2019</title>

    <link rel="stylesheet" href="css/reset.css" />
    <link rel="stylesheet" href="css/reveal.css" />
    <link rel="stylesheet" href="css/theme/black.css" />

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/monokai.css" />

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement("link");
      link.rel = "stylesheet";
      link.type = "text/css";
      link.href = window.location.search.match(/print-pdf/gi)
        ? "css/print/pdf.css"
        : "css/print/paper.css";
      document.getElementsByTagName("head")[0].appendChild(link);
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">

        <!--Cover-->

        <section>
          <h1>JavaScript</h1>
          <img src="images/js_kills.jpg" width="40%" height="40%" />
        </section>

        <!--Intro-->        

        <section>
          <!--Cover-->
          <section>
            <h3>JavaScript Language Basics</h3>
            <img src="images/hoping_this_works.jpg" width="40%" height="40%" />
          </section>

          <!--What is JavaScript-->
          <section>
            <h3>What is JavaScript</h3>
            <ul>
              <li>Lightwight</li>
              <li>Cross-platform</li>
              <li>Object-oriented</li>
            </ul>
            <aside class="notes">
              - Lightwight: não consome muita memória do computador.<br /><br />
              - Cross-platform: pode ser usado em múltiplas plataformas e
              sistemas, não apenas para web dev.<br /><br />
              - Object-oriented: é basead a em objectos
            </aside>
          </section>

          <!--Primitive Data Type-->
          <section>
            <h3>Primitive Data Types</h3>
            <table>
              <thead>
                <td>Type</td>
                <td>Values</td>
              </thead>
              <tr>
                <td>Undefined</td>
                <td>undefined</td>
              </tr>
              <tr>
                <td>Null</td>
                <td>null</td>
              </tr>
              <tr>
                <td>Number</td>
                <td>-1, 0, 1.5, 5.7e+308, -Infinity, +Infinity, NaN</td>
              </tr>
              <tr>
                <td>String</td>
                <td>'Ze', "Manel"</td>
              </tr>
              <tr>
                <td>Boolean</td>
                <td>true, false</td>
              </tr>
            </table>

            <aside class="notes">
              - A primitive value is an immutable piece of data that is
              represented directly at the lowest level of the language
              implementation. Não são objectos como a maioria do resto em js.<br />

              - Undefined: Data type of a variable that does not have a value
              yet. So is the value that is automatically assigned if a value is
              not provided.<br /><br />
              - Null: 'Non-existent' value that represents the intentional
              absence of any object value<br /><br />
              - Number: Floating point numbers, for decimal and integers. Always
              floating point numbers. All have decimals even we sometimes don't
              see or even don't define them.<br /><br />
              - String: Sequence of characters, used for text<br /><br />
              - Boolean: Logical data type that can only be true or false<br /><br>
              falar dos Primitive Wrappers
            </aside>
          </section>

          <!--Dynamic Typing-->
          <section>
            <h3>Primitive Data Types</h3>
            <img src="images/null_vs_undefined.jpg" width="50%" height="50%" />
          </section>

          <!--Dynamic Typing-->
          <section width="100%">
            <h3>Dynamic Typing</h3>
            <pre><code data-trim data-line-numbers contenteditable="true">
              var taxit = 15;	// Number
              taxit = 'great';	// now is a String
              taxit = { members: 15, office: 'somewhere' }	// Object
            </code></pre>
            <div style="display: inline-block;" class="fragment fade-up">
              How to return the type of a value?
              <pre width="100%"><code data-trim>
              console.log(typeof taxit);
              // result?
            </code></pre>
            </div>
            <div style="display: inline-block;" class="fragment fade-up">
              What if...
              <pre><code data-trim>
              var hello = 'Hi';
              var size = 15;
              console.log(hello + ' ' + size);
              </code>
              </pre>
              "size" is a number but is logged as a string...Why?
            </div>
            <aside class="notes">
              - JavaScript has dynamic typing: data types are automatically
              assigned to variables. If later we assign another value with
              another type, js will automatically change the data type of the
              variable as well.<br /><br />

              - No caso do exemplo anterior, converte o valor numérico em
              string, de forma a concatenar a strings para ser impresso pelo
              console.log que escreve...strings
            </aside>
          </section>

          <!--Type Coercion-->
          <section>
            <h3>Type Coercion</h3>
            <pre><code data-trim data-line-numbers contenteditable="true">
              1 + 2 + '3'; // '33'
              1 + '2' + 3; // '123'
              1 + true + true + false; // 3
              true + '1'; // 'true1'
              1 + ''; / '1'
              '5' * 3; // 15
              '5' * false; // 0
              2 / '2'; // 1
              2 / 'a'; // NaN
              2 + null + ''; // '2'
              null + true; // 1
			      </code></pre>
            <b>Type Coercion</b> works thanks to <b>==</b> operator. To avoid
            type coercion, use strict equality <b>===</b>.
          
            <aside class="notes">
              - Conversão implicita.<br /><br />
              - JavaScript converte automaticamente de uns types pra outros, como
              precisar.<br /><br />
              - +: em JavaScript converte qualquer um dos operandos para string se
              pelo menos um for string<br /><br />
              - Numeros com booleans: booleans são coercidos para números pois são
              considerados e implementados como valores numéricos com o digito
              binário (bit)<br /><br />
              - === verifica se o valor é o mesmo e se tem o mesmo tipo<br /><br />
              - == verifica apenas se os valores podem ser coercidos um no outro
            </aside>
          </section>

          <!--Type Coercion: Falsy-->
          <section>
            <h5>Type Coercion</h5>
            <h3>Falsy Values</h3>
            <ul>
              <li>false</li>
              <li>0</li>
              <li>'' or ""</li>
              <li>null</li>
              <li>undefined</li>
              <li>NaN</li>
            </ul>
            <img src="images/not_a_pipe.jpg" width="40%" height="40%" />
            <h3>Truthy Values</h3>
            ! Falsy Values
            <aside class="notes">
              - The falsy values in JavaScript are values that can be coerced into false. There are six falsy values, with everything else being truthy.<br><br>
              - You may be wondering why JavaScript has both null and undefined, and what the difference may be between the two.<br><br>
              Typically, undefined is when a value has not been defined by the user. When accessing an index in an array or a key in an object that doesn’t exist, you may get undefined.
              Similarly, if you have defined a variable or a flunction but you misspell it when trying to use it, you may get an error such as variable is not defined.<br><br>
              - Null, however, does not imply that a value has been forgotten to be declared or doesn’t exist.
            Typically, a human has intentionally assigned a value to null to imply that the value should start out as null but may possibly change.
            </aside>
          </section>

          <section>
            <h3>Objects</h3>
            <img src="images/orly-tyring-stuff-until-it-works.jpg" width="50%" height="50%" />
          </section>

          <!--Functions: Function Statement/Declarations-->
          <section>
            <h5>Functions</h5>
            <h3>Function Statement/Declarations</h3>
            <pre><code data-trim data-line-numbers contenteditable="true">
              function add(num1, num2) {
                return num1 + num2;
              }
            </code></pre>
            <ul>
              <li>A function statement declares a function</li>
              <li>They have a name</li>
              <li>Load before any code is executed (thanks to <b>Hoisting</b>)</li>
              <li>Use when you want to create a function on the global <b>scope</b> and make it available throughout your code</li>
            </ul>
            <aside class="notes">
              - <b>Function declarations/statements:</b> funções com nome que executam acções. Isto é, fazem coisas mas não produzem resultados imediatos.<br><br>
              - if...else, while loop e declaração de funções não produzem valores imediatos, sendo chamados de statements.<br><br>
              - <b>Hoisting:</b> Specifically, all of the functions written with function declarations are “known” before any code is run.
                This allows you to call a function before you declare. The objects are initialized at compile time and available anywhere in your file.
            </aside>
          </section>

          <!--Functions: Function Expressions-->
          <section>
            <h5>Functions</h5>
            <h3>Function Expressions</h3>
            <pre><code data-trim data-line-numbers contenteditable="true">
              var add = function(a1, b2) {
                return a1 + b2;
              };
              add(1, 2);  // 3 :-)
            </code></pre>
            <ul>
              <li>The name may be ommitted, making that function "anonymous"</li>
              <li>Do not <b>hoist</b>.</li>
              <li>Use to avoid polluting the global scope. (e.g. IIFE)</li>
            </ul>
            <pre><code data-trim data-line-numbers contenteditable="true">
              add(1, 2);  // BOOM! :-(
              var add = function(a1, b2) {
                return a1 + b2;
              };
            </code></pre>
            <aside class="notes">
              - <b>Function expressions:</b> o nome pode ser emitido, tornando-as anónimas. Produzem sempre um valor. Sempre que o JavaScript espera um valor,
                temos que escrever uma expresão.<br><br>                
              - Instead of your program being aware of many different functions, when you keep them anonymous, they are used and forgotten immediately.<br><br>
              - Which one you chose is almost entirely a matter of personal taste. I think the more important thing is to pick one style of 
                writing functions and stick with it throughout your script.<br><br>
              - <b>IIFE:</b> Immediately Invoked Function Expressions.
              </aside>
          </section>

          <!--IIE-->
          <section>
            <h5>Functions</h5>
            <h3>IIFE</h3>
            <pre><code data-trim data-line-numbers contenteditable="true">
            (
              function() {
                var team = 'taxit';
              }
            )();

            console.log(team);  // undefined because it isn't available
            </code></pre>
            It allows to avoid global scope pollution.
            <aside class="notes">
              - This function will execute immediately<br><br>
              - Extra parenthesis are required to tell the interpreter<br><br>
              - This is a function expression and not a declaration
            </aside>
          </section>

          <!--Arrays-->
          <section>
            <h3>Arrays</h3>
            List-like <b>objects</b>
            <pre><code data-trim data-line-numbers contenteditable="true">
              var arr = [ 'taxit', 12, true, { slb: 38 } ];
              // arr = new Array('taxit', 12, true, { slb: 38 }); is ok
              arr[0]; // 'taxit'
              arr[1]; // 12
              arr[2]; // true
              arr[3]; // { slb : 38 }
              arr.length; // 4
              typeof arr;     // ?
              arr[9] = null;
              arr.length;     // ?
              typeof arr[4]; // ?
            </code></pre>
            <aside class="notes">
              - object, 10, 5<br><br>
            </aside>
          </section>

          <!--Arrays: Queues and Stacks-->
          <section>
            <h5>Arrays</h5>
            <h3>Queues & Stacks</h3>
            <table>
              <tr><td>
                <pre><code data-trim data-line-numbers contenteditable="true">
                  var queue = [];
                  queue.push('s');
                  queue.push('l');
                  queue.push('b');

                  queue.shift(); // 's'
                  queue.shift(); // 'l'
                  queue.shift(); // 'b'
                  queue.shift(); // undefined
                </code></pre>
              </td><td>
                <pre><code data-trim data-line-numbers contenteditable="true">
                  var stack = [];
                  stack.push('s');
                  stack.push('l');
                  stack.push('b');

                  stack.pop(); // 'b'
                  stack.pop(); // 'l'
                  stack.pop(); // 'b'
                  stack.pop(); // undefined
                </code></pre>
              </td></tr>
            </table>
            <aside class="notes">
              - object, 10, 5<br><br>
            </aside>
          </section>

          <!--Arrays: Functional style-->
          <section>
            <h5>Arrays</h5>
            <h3>Functional Style</h3>
            <pre><code data-trim data-line-numbers contenteditable="true">
            // apply a filter function to an array
            var persons = [{ name: 'Rui', age: 43 }, { name: 'Pedro', age: 29 }];
            var old = persons.filter(function(person) {
              return person.age > 40;
            });
            
            // apply a transform function to an array, transforming each element
            var numbers = [1, 4, 9];
            var roots = numbers.map(Math.sqrt); // [1, 2, 3]
            
            // reduce an array to one single value
            var animals = ['cat', 'dog', 'fish'];
            var letters = animals.reduce(function(sum, word) {
              return sum + word.length;
            }, 0); // 10

            // code from Academia de Código

            </code></pre>
            <aside class="notes">
              - Importante: The original array objects are not mutated by map, filter or reduce
            </aside>
          </section>

          <!-- Arrays: iteration and how to copy?-->
          <section>
            <h5>Arrays</h5>
            <h3>Iteration</h3>
            A classic <b>for loop</b> works, however, you can use a forEach (impossible to break early)
            <pre width="100%"><code data-trim data-line-numbers contenteditable="true">
              words.forEach(function(word) {
                console.log(word + ' has ' + word.length + ' letters.');
              });
            </code></pre>
            <div style="display: inline-block;" class="fragment fade-up">
              <h3>How to copy an array?</h3>
            </div><br>
            <div style="display: inline-block;" class="fragment fade-up" width="100%">
              <pre><code data-trim data-line-numbers contenteditable="true">
                var a = [1, 9, 0, 4];
                var b = a;
                a.push(38);
                a = // ?
                b = // ?
              </code></pre>
            </div>
            <aside class="notes">
            **b = a.slice();** para cópia integral do array. Pode especificar (a partir de posicao, até posicao)<br><br>
            Arrays sao mutaveis, estamos a mexer diretamente com referencias de memoria
            </aside>
          </section>

          <!--References-->
          <section>
            <h3>References</h3>
            <div style="display: inline-block;" class="fragment fade-up">
              <ul>
                <li>Variables can hold the actual values of primitives types</li>
                <li>or references to objects</li>
            </div>
            <div style="display: inline-block;" class="fragment fade-up">
              <table border="0">
                <tr>
                  <td align="center">
                    <img src="images/ref_1.png" width="600%" height="40%" />
                  </td>
                  <td align="center">
                    <img src="images/ref_2.png" width="60%" height="40%" />
                  </td>
                </tr>
              </table>
              <br><br>
              <span style="font-size:12px">Images from Academia de Código</span>
            </div>
          </section>

          <!--Challenge 1-->
          <section>
            <h3>Challenge 1</h3>
            <h1>Tip Calculator</h1>
          </section>

          <!--Challenge 1-->
          <section>
            <h3>Challenge 1: Tip Calculator</h3>
            <ul>
              <li>functions</li>
              <li>arrays</li>
            </ul>
            <br><br>
            <a href="exercises/1/1.html" target="_blank">"Source code"</a>
          </section>

          <!--Objects-->
          <section>
            <h3>Objects</h3>
            <ul>
              <li>A collection of properties</li>
              <li> {key: value} pairs</li>
              <li>Everything that is not a primitive, is an Object</li>
            </ul>
            <pre><code data-trim data-line-numbers contenteditable="true">
              var obj = {
                a: 'hi',
                b: 42,
                c: true
              };
              // or
              var person = new Object();
              person.name = ['Bruno Lage'];
              person['age']: 43;
            </code></pre>
            <table width="100%">
              <tr>
                <td width="50%">
                  <pre width="100%"><code data-trim data-line-numbers contenteditable="true">
                    obj.a; // 'hi'
                    obj.b; // 42
                    obj.c; // true
                  </code></pre>
                </td>
                <td width="50%">
                  <pre width="100%"><code data-trim data-line-numbers contenteditable="true">
                    obj["a"]; // 'hi'
                    obj["b"]; // 42
                    obj["c"]; // true
                  </code></pre>
                </td>
              </tr>
            </table>
          </section>
            
          <!--Objects and methods-->
          <section>
            <h5>Objects</h5>
            <h3>Methods</h3>
            <pre><code data-trim data-line-numbers contenteditable="true">
              var obj = {
                name: 'Bruno Lage',
                birthYear: 1976,
                calcAge: function(birthYear) {
                  this.age =  2019 - this.birthYear;
                };
              };
              // or
              var person = new Object();
              person.name = ['Bruno Lage'];
              person['age']: 43;
            </code></pre>
            <aside class="notes">
              - o <i>this</i> aponta para o presente/atual objecto
            </aside>
          </section>

          <!--Challenge 2-->
          <section>
            <h3>Challenge 2</h3>
            <h1>BMI Calculator</h1>
            <h5>Body Mass Index</h5>
          </section>

          <!--Challenge 2-->
          <section>
            <h3>Challenge 2: BMI Calculator</h3>
            <ul>
              <li>Objects</li>
              <li>methods</li>
            </ul>
            <br><br>
            <a href="exercises/2/2.html" target="_blank">"Source code"</a>
          </section>
        </section>

        <!-- Behind the scenes--> 

        <section>

          <!--Cover-->
          <section>
            <h3>JavaScript Behind the Scenes</h3>
            <img src="images/pretending.jpg" width="40%" height="40%" />
          </section>
          
          <!--How code is exectued-->
          <section>
            <h3>How code is executed</h3>
            <h5>The code</h5>
            <pre><code data-trim data-line-numbers contenteditable="true">
            var hello = "Hello World!";
            </code></pre>
            <div style="display: inline-block;" class="fragment fade-up">
              <h5>JavaScript Engine</h5>
              <img src="images/js_engine.png" width="100%" height="100%" />
            </div><br>
            <aside class="notes">
            - JS is hosted in some environment: typically a browser or a web server (node)<br><br>
            - Host esse tem uma espécie de JavaScript engine (e.g.: Google V8) que interpreta e executa o nosso código<br><br>
            - The region of the program where a binding between a variable and its name is valid<br><br>
            - 1. O código é analisado por um parser que lê o código linha a linha para analisar se sintaxe ok;<br>
            Parser sabe as regras do JS de forma em como deve ser escrito. Se encontra erro, emite erro e para execução<br><br>
            - 2. Se tudo ok, parser produz estrutra de dados (Abstract Syntax Tree) que, de seguida, é traduzido para código máquina.<br>
            Deixa de ser código JS para ser um conjunto de instruções
            - 3. Se tudo ok, então corre
            </aside>
          </section>

          <!--Lexical Scope-->
          <section>
            <h3>Lexical Scope</h3>
            "is based on where variables and blocks of scope are authored/declared, by you, at write time"<br>
            <pre><code data-trim data-line-numbers contenteditable="true">
              function foo(a) { // global scope
                var b = a * 2;  // foo scope (local scope)
                function bar(c) { // bar scope (local scope)
                  console.log(a, b, c);
                }
                bar(b * 3);
              }
              foo(2); // ? 
            </code></pre>
            <span style="font-size:12px;">You don't know JS: Scopes & Closures</span>
            <aside class="notes">
            - 2, 4, 12<br><br>
            - <b>global scope:</b> engloba apenas a função <b>foo</b><br><br>
            - <b>foo scope:</b>engloba <b>a</b>, <b>bar</b> e <b>b</b><br><br>
            - <b>bar scope:</b> engloba apenas a variável <b>c</b>><br><br>
            - Engine executa o console.log e vai procurar referências das variáveis a,b e c. Começa no scope mais interno
            e vai subindo até encontrar. Para na primeira correspondência.
            </aside>
          </section>

          <!--Hoisting-->
          <section>
            <h3>Hoisting</h3>
            <img src="images/chicken_egg.jpg" width="50%" height="50%">
            <br>
            <span style="font-size: 24px;">
              Variables and functions <b>declarations</b> are "moved" from where they appear in the flow of the code to the top of the code.
            </span>
            <div style="display: inline-block;" class="fragment fade-up"  width="100%">
              <table width="100%">
                <tr>
                  <td width="50%">
                    <pre width="100%"><code data-trim data-line-numbers contenteditable="true">
                      a = 2;
                      var a;
                      console.log(a); // ?
                    </code></pre>
                  </td>
                  <td width="50%">
                    <pre width="100%"><code data-trim data-line-numbers contenteditable="true">
                      console.log(a); // ?
                      var a = 2;
                    </code></pre>
                  </td>
                </tr>
              </table>
            </div>
            <aside class="notes">
            - 2 e undefined<br><br>
            - <b>ovo:</b> declaração. <b>galinha:</b> atribuição do valor;
            </aside>
          </section>
          
          <!--Hoisting: Chicken or the Egg?-->
          <section>
            <h5>Hoisting</h5>
            <h3>Chicken or the Egg?</h3>
            <pre width="100%"><code data-trim data-line-numbers contenteditable="true">
              var a = 2;
            </code></pre>
            <ul>
              <li>For JavaScript there are 2 statements:</li>
              <pre width="100%"><code data-trim data-line-numbers contenteditable="true">
                var = a;  // (egg: declaration - compilation)
                a = 2;    // (chicken: assignment - execution phase)
              </code></pre>
              <div style="display: inline-block;" class="fragment fade-up">
                <li>In other words, the egg (declaration) comes before the chicken (assignment)</li>
              </div>
            </ul>
            <br>
            <div style="display: inline-block;" class="fragment fade-up">
              <img src="images/eggs.jpg" width="35%" height="35%">
            </div>
            <aside class="notes">
            - Hoisting is per-scope.<br><br>
            - Declaração de funções e variáveis são hoisted, mas as funções são hoisted primeiro que as variáveis<br><br>
            
            foo(); // 1<br>
            var foo;<br>
            function foo() { console.log(1); }<br>
            foo = function() { console.log(2); }<br>
            <br><br>
            este código é interpretado pelo engine como:
            <br><br>
            function foo() { console.log(1); }<br>
            foo(); // 1<br>
            foo = function() { console.log(2); }<br>
            </aside>
          </section>

        </section>
      </div>
    </div>

    <script src="js/reveal.js"></script>

    <script>
      // More info about config & dependencies:
      // - https://github.com/hakimel/reveal.js#configuration
      // - https://github.com/hakimel/reveal.js#dependencies
      Reveal.initialize({
        dependencies: [
          { src: "plugin/markdown/marked.js" },
          { src: "plugin/markdown/markdown.js" },
          { src: "plugin/notes/notes.js", async: true },
          { src: "plugin/highlight/highlight.js", async: true }
        ]
      });
    </script>
  </body>
</html>
