<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>TaxIT 2019</title>

    <link rel="stylesheet" href="css/reset.css" />
    <link rel="stylesheet" href="css/reveal.css" />
    <link rel="stylesheet" href="css/theme/black.css" />

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/monokai.css" />

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement("link");
      link.rel = "stylesheet";
      link.type = "text/css";
      link.href = window.location.search.match(/print-pdf/gi)
        ? "css/print/pdf.css"
        : "css/print/paper.css";
      document.getElementsByTagName("head")[0].appendChild(link);
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">

        <!--Cover-->

        <section>
          <h1>JavaScript</h1>
          <img src="images/js_kills.jpg" width="40%" height="40%" />
        </section>

        <!--Intro-->        

        <section>
          <!--Cover-->
          <section>
            <h3>JavaScript Language Basics</h3>
            <img src="images/hoping_this_works.jpg" width="40%" height="40%" />
          </section>

          <!--in the beginning-->
          <section>
            <h3>Brendan Eich</h3>
            <img src="images/iamyourfather_js.png" />
            <br>
            <ul>
              <li>Netscape Communications, 1995</li>
              <li>He developed the 1st prototype in 10 days</li>
              <li>Java is to JavaScript as Car is to Carpet</li>
            </ul>
          </section>

          <!--What is JavaScript-->
          <section>
            <h3>What is JavaScript</h3>
            <ul>
              <li>Lightweight</li>
              <li>Cross-platform</li>
              <li>Object-oriented</li>
            </ul>
            <aside class="notes">
              - <b>Lightweight:</b> não consome muita memória do computador.<br /><br />
              - <b>Cross-platform:</b> pode ser usado em múltiplas plataformas e
              sistemas, não apenas para web dev.<br /><br />
              - <b>Object-oriented:</b> é baseada em objectos
            </aside>
          </section>

          <!--Primitive Data Type-->
          <section>
            <h3>Primitive Data Types</h3>
            <table>
              <thead>
                <td>Type</td>
                <td>Values</td>
              </thead>
              <tr>
                <td>Undefined</td>
                <td>undefined</td>
              </tr>
              <tr>
                <td>Null</td>
                <td>null</td>
              </tr>
              <tr>
                <td>Number</td>
                <td>-1, 0, 1.5, 5.7e+308, -Infinity, +Infinity, NaN</td>
              </tr>
              <tr>
                <td>String</td>
                <td>'Ze', "Manel"</td>
              </tr>
              <tr>
                <td>Boolean</td>
                <td>true, false</td>
              </tr>
            </table>

            <aside class="notes">
              - A <b>primitive value</b> is an immutable piece of data that is
              represented directly at the lowest level of the language
              implementation. Não são objectos como a maioria do resto em js.<br><br>

              - <b>Undefined:</b> Data type of a variable that does not have a value
              yet. So is the value that is automatically assigned if a value is
              not provided.<br /><br />
              - <b>Null:</b> 'Non-existent' value that represents the intentional
              absence of any object value. É do tipo <b>object</b>, o que é um bug<br /><br />
              - <b>Number:</b> Floating point numbers, for decimal and integers. Always
              floating point numbers. All have decimals even we sometimes don't
              see or even don't define them.<br /><br />
              - <b>String:</b> Sequence of characters, used for text<br /><br />
              - <b>Boolean:</b> Logical data type that can only be true or false<br /><br>
              falar dos Primitive Wrappers
            </aside>
          </section>

          <!--Dynamic Typing-->
          <section>
            <h3>Primitive Data Types</h3>
            <img src="images/null_vs_undefined.jpg" width="50%" height="50%" />
          </section>

          <!--Dynamic Typing-->
          <section width="100%">
            <h3>Dynamic Typing</h3>
            <pre style="width: 100%;"><code data-trim data-line-numbers contenteditable="true">
              var taxit = 15;	// Number
              taxit = 'great';	// now is a String
              taxit = { members: 15, office: 'somewhere' }	// Object
            </code></pre>
            <div style="display: inline-block;" class="fragment fade-up">
              How to return the type of a value?
              <pre width="100%"><code data-trim>
              console.log(typeof taxit);
              // result?
            </code></pre>
            </div>
            <div style="display: inline-block;" class="fragment fade-up">
              What if...
              <pre style="width: 100%;"><code data-trim>
              var hello = 'Hi';
              var size = 15;
              console.log(hello + ' ' + size);
              </code>
              </pre>
              "size" is a number but is logged as a string...Why?
            </div>
            <aside class="notes">
              - JavaScript has dynamic typing: data types are automatically
              assigned to variables. If later we assign another value with
              another type, js will automatically change the data type of the
              variable as well.<br /><br />

              - No caso do exemplo anterior, converte o valor numérico em
              string, de forma a concatenar a strings para ser impresso pelo
              console.log que escreve...strings
            </aside>
          </section>

          <!--Type Coercion-->
          <section>
            <h3>Type Coercion</h3>
            <pre><code data-trim data-line-numbers contenteditable="true">
              1 + 2 + '3'; // '33'
              1 + '2' + 3; // '123'
              1 + true + true + false; // 3
              true + '1'; // 'true1'
              1 + ''; / '1'
              '5' * 3; // 15
              '5' * false; // 0
              2 / '2'; // 1
              2 / 'a'; // NaN
              2 + null + ''; // '2'
              null + true; // 1
			      </code></pre>
            <b>Type Coercion</b> works thanks to <b>==</b> operator. To avoid
            type coercion, use strict equality <b>===</b>.
          
            <aside class="notes">
              - <b>Conversão implicita</b>.<br /><br />
              - JavaScript converte automaticamente de uns types pra outros, como
              precisar.<br /><br />
              - <b>+:</b> em JavaScript converte qualquer um dos operandos para string se
              pelo menos um for string<br /><br />
              - <b>Numeros com booleans:</b> booleans são coercidos para números pois são
              considerados e implementados como valores numéricos com o digito
              binário (bit)<br /><br />
              - <b>===</b> verifica se o valor é o mesmo e se tem o mesmo tipo<br /><br />
              - <b>==</b> verifica apenas se os valores podem ser coercidos um no outro
            </aside>
          </section>

          <!--Type Coercion: Falsy-->
          <section>
            <h5>Type Coercion</h5>
            <h3>Falsy Values</h3>
            <ul>
              <li>false</li>
              <li>0</li>
              <li>'' or ""</li>
              <li>null</li>
              <li>undefined</li>
              <li>NaN</li>
            </ul>
            <img src="images/not_a_pipe.jpg" width="40%" height="40%" />
            <h3>Truthy Values</h3>
            ! Falsy Values
            <aside class="notes">
              - The falsy values in JavaScript are values that can be coerced into false. There are six falsy values, with everything else being truthy.<br><br>
              - You may be wondering why JavaScript has both <b>null</b> and <b>undefined</b>, and what the <b>difference</b> may be between the two.<br><br>
              Typically, <b>undefined</b> is when a value has not been defined by the user. When accessing an index in an array or a key in an object that doesn’t exist, you may get undefined.
              Similarly, if you have defined a variable or a flunction but you misspell it when trying to use it, you may get an error such as variable is not defined.<br><br>
              - <b>Null</b>, however, does not imply that a value has been forgotten to be declared or doesn’t exist.
            Typically, a human has intentionally assigned a value to null to imply that the value should start out as null but may possibly change.
            </aside>
          </section>

          <section>
            <h3>Objects</h3>
            <img src="images/orly-tyring-stuff-until-it-works.jpg" width="45%" height="45%" />
          </section>

          <!--Functions: Function Statement/Declarations-->
          <section>
            <h5>Functions</h5>
            <h3>Function Statement/Declarations</h3>
            <pre><code data-trim data-line-numbers contenteditable="true">
              function add(num1, num2) {
                return num1 + num2;
              }
            </code></pre>
            <ul>
              <li>A function statement declares a function</li>
              <li>They have a name</li>
              <li>Load before any code is executed (thanks to <b>Hoisting</b>)</li>
              <li>Use when you want to create a function on the global <b>scope</b> and make it available throughout your code</li>
            </ul>
            <aside class="notes">
              - <b>Function declarations/statements:</b> funções com nome que executam acções. Isto é, fazem coisas mas não produzem resultados imediatos.<br><br>
              - if...else, while loop e declaração de funções não produzem valores imediatos, sendo chamados de statements.<br><br>
              - <b>Hoisting:</b> Specifically, all of the functions written with function declarations are “known” before any code is run.
                This allows you to call a function before you declare. The objects are initialized at compile time and available anywhere in your file.
            </aside>
          </section>

          <!--Functions: Function Expressions-->
          <section>
            <h5>Functions</h5>
            <h3>Function Expressions</h3>
            <pre><code data-trim data-line-numbers contenteditable="true">
              var add = function(a1, b2) {
                return a1 + b2;
              };
              add(1, 2);  // 3 :-)
            </code></pre>
            <ul>
              <li>The name may be ommitted, making that function "anonymous"</li>
              <li>Do not <b>hoist</b>.</li>
              <li>Use to avoid polluting the global scope. (e.g. IIFE)</li>
            </ul>
            <pre><code data-trim data-line-numbers contenteditable="true">
              add(1, 2);  // BOOM! :-(
              var add = function(a1, b2) {
                return a1 + b2;
              };
            </code></pre>
            <aside class="notes">
              - <b>Function expressions:</b> o nome pode ser emitido, tornando-as anónimas. Produzem sempre um valor. Sempre que o JavaScript espera um valor,
                temos que escrever uma expresão.<br><br>                
              - Instead of your program being aware of many different functions, when you keep them anonymous, they are used and forgotten immediately.<br><br>
              - Which one you chose is almost entirely a matter of personal taste. I think the more important thing is to pick one style of 
                writing functions and stick with it throughout your script.<br><br>
              - <b>IIFE:</b> Immediately Invoked Function Expressions.
              </aside>
          </section>

          <!--IIE-->
          <section>
            <h5>Functions</h5>
            <h3>IIFE</h3>
            <pre><code data-trim data-line-numbers contenteditable="true">
            (
              function() {
                var team = 'taxit';
              }
            )();

            console.log(team);  // undefined because it isn't available
            </code></pre>
            It allows to avoid global scope pollution.
            <aside class="notes">
              - This function will execute immediately<br><br>
              - Extra parenthesis are required to tell the interpreter<br><br>
              - This is a function expression and not a declaration
            </aside>
          </section>

          <!--Arrays-->
          <section>
            <h3>Arrays</h3>
            List-like <b>objects</b>
            <pre><code data-trim data-line-numbers contenteditable="true">
              var arr = [ 'taxit', 12, true, { slb: 38 } ];
              // arr = new Array('taxit', 12, true, { slb: 38 }); is ok
              arr[0]; // 'taxit'
              arr[1]; // 12
              arr[2]; // true
              arr[3]; // { slb : 38 }
              arr.length; // 4
              typeof arr;     // ?
              arr[9] = null;
              arr.length;     // ?
              typeof arr[4]; // ?
            </code></pre>
            <aside class="notes">
              - object<br><br>
              - 10<br><br>
              - undefined<br><br>
            </aside>
          </section>

          <!--Arrays: Queues and Stacks-->
          <section>
            <h5>Arrays</h5>
            <h3>Queues & Stacks</h3>
            <table>
              <tr><td>
                <pre style="width: 100%;"><code data-trim data-line-numbers contenteditable="true">
                  var queue = [];
                  queue.push('s');
                  queue.push('l');
                  queue.push('b');

                  queue.shift(); // 's'
                  queue.shift(); // 'l'
                  queue.shift(); // 'b'
                  queue.shift(); // undefined
                </code></pre>
              </td><td>
                <pre style="width: 100%;"><code data-trim data-line-numbers contenteditable="true">
                  var stack = [];
                  stack.push('s');
                  stack.push('l');
                  stack.push('b');

                  stack.pop(); // 'b'
                  stack.pop(); // 'l'
                  stack.pop(); // 's'
                  stack.pop(); // undefined
                </code></pre>
              </td></tr>
            </table>
            <aside class="notes">
              tem o <b>.unshift()</b> que coloca elementos no início do array
            </aside>
          </section>

          <!--Arrays: Functional style-->
          <section>
            <h5>Arrays</h5>
            <h3>Functional Style</h3>
            <pre style="width: 100%; height: 100%;"><code data-trim data-line-numbers contenteditable="true">
            // apply a filter function to an array
            var persons = [{ name: 'Rui', age: 43 }, { name: 'Pedro', age: 29 }];
            var old = persons.filter(function(person) {
              return person.age > 40;
            });
            
            // apply a transform function to an array, transforming each element
            var numbers = [1, 4, 9];
            var roots = numbers.map(Math.sqrt); // [1, 2, 3]
            
            // reduce an array to one single value
            var animals = ['cat', 'dog', 'fish'];
            var letters = animals.reduce(function(sum, word) {
              return sum + word.length;
            }, 0); // 10

            </code></pre>
            <aside class="notes">
              - <b>Importante:</b> The original array objects are not mutated by map, filter or reduce
              <br><br>
              Na prática retorna uma cópia
            </aside>
          </section>

          <!-- Arrays: iteration and how to copy?-->
          <section>
            <h5>Arrays</h5>
            <h3>How to copy an array?</h3>
            <br>
            <div style="display: inline-block;" class="fragment fade-up" width="100%">
              <pre style="width: 100%;"><code data-trim data-line-numbers contenteditable="true">
                var a = [1, 9, 0, 4];
                var b = a;
                a.push(38);
                a = // ?
                b = // ?
              </code></pre>
            </div>
            <aside class="notes">
              <b>a</b> e <b>b</b> ficam iguais, ou seja [1, 9, 0, 4, 38]            
              <br><br>
              <b>b = a.slice();</b> para cópia integral do array.
              <br><br>Pode especificar (a partir de posicao, até posicao)<br><br>
              Arrays sao mutaveis, estamos a mexer diretamente com referencias de memoria<br><br>
              Para <b>copiar um objecto</b>, podemos usar o <b>spread operator</b> (ES6)<br>
              var obj = { foo: "foo", bar: "bar" };<br>
              var clonedObj = { ...obj };<br><br>
              ou o <b>Object.assign</b><br><br>
                var obj = { foo: "foo", bar: "bar" };<br>
                var clonedObj = Object.assign({}, obj);
            </aside>
          </section>

          <!--References-->
          <section>
            <h3>References</h3>
            <div style="display: inline-block;" class="fragment fade-up">
              <ul>
                <li>Variables can hold the actual values of primitives types</li>
                <li>or references to objects</li>
            </div>
            <div style="display: inline-block;" class="fragment fade-up">
              <table border="0">
                <tr>
                  <td align="center">
                    <img src="images/ref_1.png" width="600%" height="40%" />
                  </td>
                  <td align="center">
                    <img src="images/ref_2.png" width="60%" height="40%" />
                  </td>
                </tr>
              </table>
              <br><br>
              <span style="font-size:12px">Images from Academia de Código</span>
            </div>
          </section>

          <!--Challenge 1-->
          <section>
            <h3>Challenge 1</h3>
            <h1>Tip Calculator</h1>
          </section>

          <!--Challenge 1-->
          <section>
            <h3>Challenge 1: Tip Calculator</h3>
            <ul>
              <li>functions</li>
              <li>arrays</li>
            </ul>
            <br><br>
            <a href="exercises/1/1.html" target="_blank">"Source code"</a>
          </section>

          <!--Objects-->
          <section>
            <h3>Objects</h3>
            <ul>
              <li>A collection of properties</li>
              <li> {key: value} pairs</li>
              <li>Everything that is not a primitive, is an Object</li>
            </ul>
            <pre><code data-trim data-line-numbers contenteditable="true">
              var obj = {
                a: 'hi',
                b: 42,
                c: true
              };
              // or
              var person = new Object();
              person.name = ['Bruno Lage'];
              person['age']: 43;
            </code></pre>
            <table width="100%">
              <tr>
                <td width="50%">
                  <pre width="100%"><code data-trim data-line-numbers contenteditable="true">
                    obj.a; // 'hi'
                    obj.b; // 42
                    obj.c; // true
                  </code></pre>
                </td>
                <td width="50%">
                  <pre width="100%"><code data-trim data-line-numbers contenteditable="true">
                    obj["a"]; // 'hi'
                    obj["b"]; // 42
                    obj["c"]; // true
                  </code></pre>
                </td>
              </tr>
            </table>
            <aside class="notes">
              mostrar como se <b>copia um objecto</b> com o <b>Object.assign({}, objecto_a_copiar)</b>
            </aside>
          </section>
            
          <!--Objects and methods-->
          <section>
            <h5>Objects</h5>
            <h3>Methods</h3>
            <pre><code data-trim data-line-numbers contenteditable="true">
              var obj = {
                name: 'Bruno Lage',
                birthYear: 1976,
                calcAge: function(birthYear) {
                  this.age =  2019 - this.birthYear;
                };
              };
              // or
              var person = new Object();
              person.name = ['Bruno Lage'];
              person['age']: 43;
            </code></pre>
            <aside class="notes">
              - o <i>this</i> aponta para o presente/atual objecto
            </aside>
          </section>

          <!--Challenge 2-->
          <section>
            <h3>Challenge 2</h3>
            <h1>BMI Calculator</h1>
            <h5>Body Mass Index</h5>
          </section>

          <!--Challenge 2-->
          <section>
            <h3>Challenge 2: BMI Calculator</h3>
            <ul>
              <li>Objects</li>
              <li>methods</li>
            </ul>
            <br><br>
            <a href="exercises/2/2.html" target="_blank">"Source code"</a>
          </section>
        </section>

        <!-- Behind the scenes--> 

        <section>

          <!--Cover-->
          <section>
            <h3>JavaScript Behind the Scenes</h3>
            <img src="images/pretending.jpg" width="40%" height="40%" />
          </section>
          
          <!--How code is exectued-->
          <section>
            <h3>How code is executed</h3>
            <h5>The code</h5>
            <pre><code data-trim data-line-numbers contenteditable="true">
            var hello = "Hello World!";
            </code></pre>
            <div style="display: inline-block;" class="fragment fade-up">
              <h5>JavaScript Engine</h5>
              <img src="images/js_engine.png" width="80%" height="80%" />
            </div><br>
            <span style="font-size:20px">
              <a href="https://d33wubrfki0l68.cloudfront.net/010de1f875240e3fe452f37e91f706bb9c20cf98/8e1c4/images/js/traversing-ast/code2ast.png" target="_blank">
              Example of an AST  
              </a>
            </span>
            <aside class="notes">
            - <b>JS is hosted in some environment:</b> typically a browser or a web server (node)<br><br>
            - Host esse tem uma espécie de <b>JavaScript engine</b> (e.g.: Google V8) que interpreta e executa o nosso código<br><br>
            - The region of the program where a binding between a variable and its name is valid<br><br>
            - 1. O código é analisado por um parser que lê o código linha a linha para analisar se sintaxe ok;<br>
            Parser sabe as regras do JS de forma em como deve ser escrito. Se encontra erro, emite erro e para execução<br><br>
            - 2. Se tudo ok, parser produz estrutra de dados (Abstract Syntax Tree) que, de seguida, é traduzido para código máquina.<br>
            Deixa de ser código JS para ser um conjunto de instruções
            - 3. Se tudo ok, então corre
            </aside>
          </section>

          <!--Lexical Scope-->
          <section>
            <h3>Lexical Scope</h3>
            "is based on where variables and blocks of scope are authored/declared, by you, at write time"<br>
            <pre><code data-trim data-line-numbers contenteditable="true">
              function foo(a) { // global scope
                var b = a * 2;  // foo scope (local scope)
                function bar(c) { // bar scope (local scope)
                  console.log(a, b, c);
                }
                bar(b * 3);
              }
              foo(2); // ? 
            </code></pre>
            <span style="font-size:12px;">You don't know JS: Scopes & Closures</span>
            <aside class="notes">
            - 2, 4, 12<br><br>
            - <b>scope</b> poderá ser entendido como o espaço onde as variáveis têm vida<br><br>
            - <b>global scope:</b> engloba apenas a função <b>foo</b><br><br>
            - <b>foo scope:</b>engloba <b>a</b>, <b>bar</b> e <b>b</b><br><br>
            - <b>bar scope:</b> engloba apenas a variável <b>c</b><br><br>
            - A relatively basic concept in JavaScript is that each declared function creates its own scope.<br><br>
            - Engine executa o console.log e vai procurar referências das variáveis a,b e c. Começa no scope mais interno
            e vai subindo até encontrar. Para na primeira correspondência.
            </aside>
          </section>

          <!--Hoisting-->
          <section>
            <h3>Hoisting</h3>
            <img src="images/chicken_egg.jpg" width="50%" height="50%">
            <br>
            <span style="font-size: 24px;">
              Variables and functions <b>declarations</b> are "moved" from where they appear in the flow of the code to the top of the code.
            </span>
            <br>
            <div style="display: inline-block;" class="fragment fade-up"  width="100%">
              <table width="100%">
                <tr>
                  <td width="50%">
                    <pre width="100%"><code data-trim data-line-numbers contenteditable="true">
                      a = 2;
                      var a;
                      console.log(a); // ?
                    </code></pre>
                  </td>
                  <td width="50%">
                    <pre width="100%"><code data-trim data-line-numbers contenteditable="true">
                      console.log(a); // ?
                      var a = 2;
                    </code></pre>
                  </td>
                </tr>
              </table>
            </div>
            <aside class="notes">
            - 2 e undefined<br><br>
            - <b>ovo:</b> declaração. <b>galinha:</b> atribuição do valor;
            </aside>
          </section>
          
          <!--Hoisting: Chicken or the Egg?-->
          <section>
            <h5>Hoisting</h5>
            <h3>Chicken or the Egg?</h3>
            <pre width="100%"><code data-trim data-line-numbers contenteditable="true">
              var a = 2;
            </code></pre>
            <ul>
              <li>For JavaScript there are 2 statements:</li>
              <pre width="100%"><code data-trim data-line-numbers contenteditable="true">
                var = a;  // (egg: declaration - compilation)
                a = 2;    // (chicken: assignment - execution phase)
              </code></pre>
              <div style="display: inline-block;" class="fragment fade-up">
                <li>In other words, the egg (declaration) comes before the chicken (assignment)</li>
              </div>
            </ul>
            <br>
            <div style="display: inline-block;" class="fragment fade-up">
              <img src="images/eggs.jpg" width="35%" height="35%">
            </div>
            <aside class="notes">
            - Hoisting is per-scope.<br><br>
            - Declaração de funções e variáveis são hoisted, mas as funções são hoisted primeiro que as variáveis<br><br>
            
            foo(); // 1<br>
            var foo;<br>
            function foo() { console.log(1); }<br>
            foo = function() { console.log(2); }<br>
            <br><br>
            este código é interpretado pelo engine como:
            <br><br>
            function foo() { console.log(1); }<br>
            foo(); // 1<br>
            foo = function() { console.log(2); }<br>
            </aside>
          </section>

          <!--Call Stack-->
          <section>
            <h5>Call Stack</h5>
            <h3>Execution Context <br>and the<br> Execution Stack</h3>
            <ul>
              <li><span style="font-size: 20px;">Execution contexts are environments where JavaScript code run.</span></li>
              <li><span style="font-size: 20px;">Imagine Execution Context like a box which store variables and which a piece of our code is evaluated and executed</span></li>
            </ul>
            <aside class="notes">
              Introduz o tema de como é executado o nosso código em JavaScript
            </aside>
          </section>

          <!--Call Stack-->
          <section>
            <h5>Execution Context and the Execution Stack</h5>
            <ul>
              <div style="display: inline-block; font-size:40px;" class="fragment fade-up">
                <li>All JavaScript code runs within the scope of what is known as an <span style="color: yellow;">Execution Context</span></li>
              </div>
              <div style="display: inline-block; font-size:40px;" class="fragment fade-up">
                <li>A <span style="color: yellow;">global execution context</span> (the default one) is created initially and pushed into the <span style="color: yellow;">call stack</span></li>
              </div>
              <div style="display: inline-block; font-size:40px;" class="fragment fade-up">
                <li>Everytime a function is <span style="color: yellow;">invoked</span> a new execution context is created and pushed into the call stack Everytime a function <span style="color: yellow;">returns</span> its execution context is popped from the call stack</li>
              </div>
            </ul>
            <div style="display: inline-block;" class="fragment fade-up">
              <span style="font-size:20px;">All the code that is not inside of any function is executed.</span><br>
              <span style="font-size:20px;">Everything declared in the global context, automatically gets attached to the <span style="color:yellow;">window</span> object (for browsers):</span>
              <pre><code data-trim data-line-numbers contenteditable="true">
                var ze = 1;
                ze == window.ze // true
              </code></pre>
            </div>
            <aside class="notes">
              - <b>Global context</b> não está em funções e está associado ao <b>global object</b>, aka window nos browsers.
            </aside>
          </section>

          <!--Call Stack: Execution Context-->
          <section>
            <h5>Execution Context</h5>
            <img src="images/execution_context.gif" width="100%" height="100%">
          </section>

          <!--Execution Context, como se passa-->
          <section>
            <h5>Execution Context: how exactly that happens?</h5>
            <table width="100%">
              <tr>
                <td width="30%" style="vertical-align: top;">
                  <img src="images/execution_context.png">
                </td>
                <td width="70%">
                  <div style="display: inline-block;" class="fragment fade-up">
                    <ol>
                      <li><b><span style="color:yellow;">Creation phase</span>:</b></li>
                        <ol>
                          <li>Creation of the <span style="color:yellow;">Variable Object (VO)</span>, aka <span style="color:yellow;">Activation Object</span></li>
                          <li>Creation of the <span style="color:yellow;">scope chain</span></li>
                          <li>Determine value of the <span style="color:yellow;">'this'</span> value</li>
                        </ol>
                      <li><b><span style="color:yellow;">Execution phase</span>:</b> the code of the function that generated the current Execution Context is ran line by line</li>
                    </ol>
                  </div>
                </td>
              </tr>
            </table>
            <aside class="notes">
              - <b>Variable Object (VO):</b> object that contains function arguments, inner variable and function declarations</br></br>
              - <b>Scope Chain:</b> contains the current variable objects as well the variable objects of all its parents</br></br>
              - <b>'this' value:</b></br></br>
            </aside>
          </section>

          <!--Execution Context: Activation Object-->
          <section>
            <h5>Execution Context</h5>
            <h3>Activation Object</h3>
            <table width="100%">
              <tr>
                <td width="50%">
                  <pre><code data-trim data-line-numbers contenteditable="true">
                    function foo(x, y) {
                      var z = 30;
                      function bar() {}
                    }
                    foo(10, 20);
                  </code></pre>
                </td>
                <td width="50%">
                  <table border="1">
                    <tr>
                      <td><b>x</b></td>
                      <td>10</td>
                    </tr>
                    <tr>
                      <td><b>y</b></td>
                      <td>20</td>
                    </tr>
                    <tr>
                      <td><b>arguments</b></td>
                      <td>{0: 10, 1: 20, ...}</td>
                    </tr>
                    <tr>
                      <td><b>z</b></td>
                      <td>30</td>
                    </tr>
                    <tr>
                      <td><b>bar</b></td>
                      <td>function</td>
                    </tr>
                  </table>
                </td>
              </tr>
            </table>
            <aside class="notes">
              - When a function is activated (called), the interpreter scans the function for arguments and local variables or local function declarations</br></br>
              - The result of this scan becomes the Activation object and is the reason why hoisting occurs</br></br>
            </aside>
          </section>

          <!--Execution Context: Scope Chain-->
          <section>
            <h5>Execution Context</h5>
            <h3>Scope Chain</h3>
            <img src="images/scope_chain.png" width="100%" height="100%">
            <aside class="notes">
              - As variáveis vão sendo procuradas nos scopes acima sempre que não encontradas onde "deviam"<br><br>
              - O sentido inverso não ocorre. O global scope não tem acesso a veriáveis b ou c</br></br>
            </aside>
          </section>

          <!--Execution Context: Execution stack vs Scope Chain-->
          <section>
            <h5>Execution Context</h5>
            <h3>Execution Stack vs Scope Chain</h3>
            <img src="images/execution_stack_vs_scope_chain.png" width="100%" height="100%">
            <aside class="notes">
              fazer umas demos random com scopes
            </aside>
          </section>

          <!--Execution Context: this-->
          <section>
            <h5>Execution Context</h5>
            <h3>The <span style="color:yellow;">this</span> keyword</h3>
            <img src="images/fuck_this.jpg" width="30%" height="30%">
          </section>

          <!--Execution Context: This-->
          <section>
            <h5>Execution Context</h5>
            <h3>The <span style="color:yellow;">this</span> keyword</h3>
            <ul>
              <li>
                <b>Regular function call:</b> the <span style="color: yellow;">this</span> keyword points at the global object (window, in the browser). The default.                
              </li>
              <li>
                <b>Method call:</b> the <span style="color: yellow;">this</span> keyword points to the object that is calling the method.
              </li>
            </ul>
            <aside class="notes">
              Métodos são funções dentro de objectos.
            </aside>
          </section>

          <!--Execution Context: This in practice & Borrow methods-->
          <section>
            <h5>Execution Context</h5>
            <h3>The <span style="color:yellow;">this</span> keyword in practice</h3>
            <div style="display: inline-block;" class="fragment fade-up">
              <h3>Also presenting <span style="color:yellow;">borrow methods</span></h3>
              <span style="font-size: 20px;">JavaScript makes it possible to use one object's method on a totally different object</span>
              
                    <pre><code data-trim data-line-numbers contenteditable="true">
                      var ze = {
                        name: 'Zé',
                        sayHi: function() {
                          console.log('Hi ' + this.name);
                        }
                      }
                    </code></pre>
              
                    <pre><code data-trim data-line-numbers contenteditable="true">
                      var to = {
                        name: 'Tó'
                      }
                      to.sayHi = ze.sayHi;
                      to.sayHi();
                    </code></pre>
              
            </div>
            <aside class="notes">
              ver support_material/1_this_in_practice.js<br><br>
              e fazendo exemplo a exemplo e ir perguntando o output
            </aside>
          </section>

          <!--Closures-->
          <section>
            <h3>Closures</h3>
            <div style="display: inline-block;" class="fragment fade-up">
              <span style="font-size: 20px;">Closure is when a function is able to remember and access its lexical scope even when that function is executing outside its lexical scope.</span>
              <br><br>
            </div>
            <div style="display: inline-block;" class="fragment fade-up">
              <span style="font-size: 20px;">A closure is a function which has access to the variable from another function’s scope. This is accomplished by creating a function inside a function. Of course, the outer function does not have access to the inner scope.</span>
              <br><br>
            </div>
            <div style="display: inline-block;" class="fragment fade-up">
                <span style="font-size: 20px;">An inner function has always access to the variables and parameters of its outer function, even after the outer function has returned.</span>
              </div>
          </section>

          <!--Closures-->
          <section>
              <h3>Closures</h3>
              <ul>
                <li>Closure is nested function which has access to the outer scope</li>
                <li>After the outer function is returned, by keeping a reference to the inner function (the closures) we prevent the outer scope to be destroyed.</li>
              </ul>
              <pre><code data-trim data-line-numbers contenteditable="true">
                function buildName(name) { 
                  var greeting = "Hello, " + name + "!"; 
                  var sayName = function() {
                      var welcome = greeting + " Welcome!";
                      console.log(greeting); 
                  };
                  return sayName; 
                }
                
                var sayMyName = buildName("John");
                sayMyName();
              </code></pre>
              <aside class="notes">
                - Whenever a function is invoked, a new scope is created for that call.<br>
                The local variable declared inside the function belong to that scope – they can only be accessed from that function -.<br>
                It’s very important to understand that before moving further.<br><br>
                
                Remember:<br><br>
                  
                - The function scope is created for a function call, not for the function itself<br><br>
                - Every function call creates a new scope<br><br>
                
                When the function has finished the execution, the scope is usually destroyed
              </aside>
            </section>

            <!--Closures-->
            <section>
              <h3>Closures</h3>
              <ul>
                <li>Every call of the outer function creates a new closure</li>
                <li>Every call of the closure interacts with the same outer scope – which is persistent</li>
                <li>Closures can be utilized to emulate the concept of classes with public and private members (<span style="color:yellow;">Module Pattern</span>)</li>
              </ul>
              <aside class="notes">
                  ver support_material/3_closure_counter_ctrl.js
              </aside>
            </section>

            <!--Closures-->
            <section data-transition="fade-in fade-out">
              <h3>Closures</h3>
              <img src="images/closure1.JPG" width="100%" height="100%">
              <aside class="notes">
                a nova função recebe um novo Execution Context, colocado no topo da Execution Stack
              </aside>
            </section>
            <section data-transition="fade-in fade-out">
              <h3>Closures</h3>
              <img src="images/closure2.JPG" width="100%" height="100%">
              <aside class="notes">
                O Execution Context tem um objecto que guardas as variáveis, scope chain e a variável this.<br><br>
                O Scope Chain mostra as variáveis a que a função tem acesso: retirement = 66, a = 'Years...'
              </aside>
            </section>
            <section data-transition="fade-in fade-out">
              <h3>Closures</h3>
              <img src="images/closure3.JPG" width="100%" height="100%">
              <aside class="notes">
                Ao sair do Execution Context (após retornar), o Variable/Activation Object e o Scope Chaing não desaparece.<br><br>
                Este é o segredo das closures. O VO permanece em memória e pode ser acedido
              </aside>
            </section>
            <section data-transition="fade-in fade-out">
              <h3>Closures</h3>
              <img src="images/closure4.JPG" width="100%" height="100%">
              <aside class="notes">
              </aside>
            </section>
            <section data-transition="fade-in fade-out">
              <h3>Closures</h3>
              <img src="images/closure5.JPG" width="100%" height="100%">
              <aside class="notes">
              </aside>
            </section>
            <section data-transition="fade-in fade-out">
              <h3>Closures</h3>
              <img src="images/closure6.JPG" width="100%" height="100%">
              <aside class="notes">
              </aside>
            </section>
            <section data-transition="fade-in fade-out">
              <h3>Closures</h3>
              <img src="images/closure7.JPG" width="100%" height="100%">
              <aside class="notes">
              </aside>
            </section>

            <!--Closures-->
            <section>
              <h3>Challenge 3: Rewrite using the power of closures</h3>
              <a href="exercises/3/3.js" target="_blank">Source code</a>
            </section>

            <!--Closures-->
            <section>
              <h5>Closure</h5>
              <h3>One more thing</h3>
              <pre><code data-trim data-line-numbers contenteditable="true">
                var funcs = [];
                for (var i = 0; i < 3; i++) {
                  // push will create new execution context with reference to i
                  funcs.push(function() {
                    console.log(i);
                  });
                }
                funcs[0](); // ?
                funcs[1](); // ?
                funcs[2](); // ?
              </code></pre>
              <div style="display: inline-block;" class="fragment fade-up">
                <span style="font-size: 20px;">How to fix this?</span>
              </div>
              <aside class="notes">
                - Push will create new execution context with reference to i<br><br>
                - Criar uma função anónima que aceita o i como param e e retorna essa função<br><br>
                - ver o support_material/3_closure_counter_ctrl.js<br><br>
                var funcs = [];<br>
                for (var i = 0; i < 3; i++) {<br>
                  // push will create new execution context with reference to i<br>
                  funcs.push((function(i) {<br>
                    return function() {<br>
                      console.log(i);<br>
                        }<br>
                  })(i));<br>
                }<br>
                funcs[0](); // 0<br>
                funcs[1](); // 1<br>
                funcs[2](); // 2<br>
              </aside>
            </section>

            <!--Objects: Inheritance and the Prototype Chain-->
            <section>
              <h5>Objects</h5>
              <h3>Inheritance<br>and the<br>Prototype Chain</h3>
            </section>

            <!--Objects: Almost everything is an object-->
            <section>
              <h5>Objects</h5>
              <h3>Almost everything is an object</h3>
              <img src="images/objects_in_js.JPG"/>
            </section>

            <!--Objects: Constructors and instances in JavaScript-->
            <section>
              <h5>Objects</h5>
              <h3>Constructors and instances in JavaScript</h3>
              <span style="font-size: 20px;">A class blueprint is required in order to create as many objects as we want.</span>
              <pre><code data-trim data-line-numbers contenteditable="true">
                /* Constructor function for objects of type Person */
                function Person(name, yearOfBirth, job) {
                  // property initialization code inside constructor function
                  this.name = name;
                  this.yearOfBirth = yearOfBirth;
                  this.job = job;
                }

                /* Instances */
                var ze = new Person('Zé', 1993, 'teacher');
                var maria = new Person('Maria', 1992, 'nurse');
              </code></pre>
              <aside class="notes">
                Um objecto que serve de blueprint para construir mais objectos deste tipo<br><br>
                Outras linguagens chamam de class.<br><br>
                Em JavaScript é chamado de Constructor ou Prototype.<br><br>
                Com base neste construtor, podemos criar tantas instancias quanto queiramos.<br><br>
                O operador new evita que a variable this aponte para o Global Object, como seria de esperar numa regular function call.<br>
                Graças ao new, o this fica a apontar para o novo objecto vazio entretanto criado.
              </aside>
            </section>

            <!--Prototype-->
            <section>
              <h3>Prototype</h3>
              <ul>
                <li>An existing object can be used as a prototype for other objects</li>
                <li>Based on a delegation mechanism in which non existent properties are looked up in prototype objects</li>
                <li>Every JavaScript has a <span style="color: yellow;">property prototype</span>, which makes inheritance possible in JavaScript</li>
                <li>The <span style="color: yellow;">prototype property</span> is where we put methods and properties that we want <span style="color: yellow;">other objects to inherite</span></li>
            </section>

            <!--Prototype property-->
            <section>
              <h3>Prototype Property</h3>
              <pre><code data-trim data-line-numbers contenteditable="true">
                function Person(name, yearOfBirth, job) {
                  this.name = name;
                  this.yearOfBirth = yearOfBirth;
                  this.job = job;
                }
                /* add method to prototype property that we want to inherite */
                Person.prototype.calculateAge = function() {
                  console.log(2019 - this.yearOfBirth);
                }
                /* Instances */
                var ze = new Person('Zé', 1993, 'teacher');
                var maria = new Person('Maria', 1992, 'nurse');
                ze.calculateAge();
                maria.calculateAge();
              </code></pre>
            </section>

            <!--Prototype chain-->
            <section>
              <h3>Prototype Chain</h3>
              <ul>
                <li>JavaScript is a prototype-base language</li>
              </ul>
              <img src="images/prototype_chain.JPG" />
              <aside class="notes">
                - Prototype-based significa que herança funciona através da utilização de prototypes.<br><br>
                - Na prática significa que todos os objectos tem uma propriedade prototype<br><br>
              </aside>
            </section>

        </section>

        <!--Async-->
        
        <section>

          <!--Intro: Asynchronous JavaScript-->
          <section>
            <h3>Asynchronous JavaScript</h3>
            <img src="images/async_intro.jpeg" style="border: 0px; width:50%; height: 50%;" />
            <aside class="notes">
              <b>Asynchronous JavaScript</b> a fancy term for some code that keeps running in the backgroun
              while our main code is still executing.<br><br>
              - Sincrono significa que uma instrução é processada uma após a outra, linha a linha
            </aside>
          </section>
          
          <!--Callback functions-->
          <section>
            <h3>Callback functions</h3>
            <ul>
              <li>A function is called a Callback when it is passed as an argument to another
                  function for later execution</li>
              <li>Callbacks can be invoked:</li>
            </ul>
            <pre><code data-trim data-line-numbers contenteditable="true">
              // synchronous callback
              function isOdd(num) {
                return num % 2;
              }

              var numbers = [1, 5, 8, 19, 232, 456];
              var oddNumbers = numbers.filter(isOdd);
            </code></pre>
            <pre><code data-trim data-line-numbers contenteditable="true">
              // asynchronous callback
              function ring() {
                console.log('RING!');
              }

              setInterval(ring, 1000);
            </code></pre>
            <aside class="notes">
                In JavaScript, functions are objects. Because of this, functions can take
                functions as arguments, and can be returned by other functions. Functions
                that do this are called higher-order functions. Any function that is passed as an
                argument is called a callback function.<br><br>
                In JavaScript, functions are first-class objects, which means they can be:<br>

                stored in a variable, object, or array<br>
                passed as an argument to a function<br>
                returned from a function
            </aside>
          </section>

          <!--An example-->
          <section>
            <h3>An example</h3>
            <table width="100%">
              <tr><td>Synchronous</td><td>Asynchronous</td></tr>
              <tr>
                <td width="50%">
                  <pre><code data-trim data-line-numbers contenteditable="true" class="fragment fade-up">
                    var second = function() {
                      console.log('Second');
                    };

                    var first = function() {
                      console.log('Start!');
                      second();
                      console.log('The end!');
                    }

                    first();
                    // ?
                  </code></pre>
                </td>
                <td width="50%">
                  <pre><code data-trim data-line-numbers contenteditable="true" class="fragment fade-up">
                    var second = function() {
                      setTimeout(function(){
                        console.log('Async!');
                      }, 2000);
                    };

                    var first = function() {
                      console.log('Start!');
                      second();
                      console.log('The end!');
                    }

                    first();
                    // ?
                  </code></pre>
                </td>
              </tr>
            </table>
            <aside class="notes">
              - No sincrono, as instruções correm uma depois da outra, linha a linha<br><br>
              - setTimeOut faz parte da API do browser e permite correr o código x tempo depois<br><br>
              - Precisamos de passar as chamadas <b>callback functions</b> para correr após o evento ocorrer,
                neste caso, passar x segundos.<br><br>
              - Contudo, o código nao para os x segundos: a função second() retorna praa a first() 
                que imprime o 'The End'. Depois, após os x segundos passarem, o 'Async!' é imprimido.<br><br>
              - Porque é que isto acontece? Porque a "magia" do código assync é correr as funções de callback
                quando os eventos acontecem/terminam. Não esperamos que uma função termine o seu trabalho,
                para fazer algo com o resultado de seguida. Em vez disso, enviamos a callback function para fazer
                o trabalho em background.<br><br>
              - As funções de callback são chamadas assim que a main thread/function estiver disponível, 
                ou seja, utilizamos para fazer trabalho futuro.<br><br>
              - Daí ser non-blocking
            </aside>
          </section>

          <!--Intro: Concurrency-->
          <section>
            <h3>Concurrency</h3>
            <img src="images/is_this_concurrency.jpg" width="40%" height="40%" />
          </section>

          <!--Concurrency: JavaScript is a:-->
          <section>
            <h3>Concurrency</h3>
            JavaScript is a:
            <br><br>
            <ul>
              <li>single threaded</li>
              <li>concurrent</li>
              <li>non-blocking</li>
              <li>asychronous</li>
            </ul>
            <br><br>
            programming language.
            <aside class="notes">
              - <b>single-thread:</b> apenas uma Call Stack (The Call Stack is a data structure which 
                records basically where in the program we are. )<br><br>
              - Em JS, quase todos os I/O são não-bloqueantes, como por exemplo:
                HTTP requests, operações de DB, leituras/escritas ao disco<br><br>
              - Na verdade o JS usa algumas APIs (que não existem no engine, V8 por exemplo)
                 para realizar operações assincronas,como "setTimeout", HTTP requests, DOM
            </aside>
          </section>

          <!--Concurrency Model-->
          <section>
            <h3>Concurrency Model</h3>
            JavaScript has a concurrency model based on an <b>event loop</b>.
            <br>
            <img src="images/event_loop.jpg" width="35%" height="35%" />
            <br>
            <span style="font-size: 20px;">This model is quite different from models in other languages like C and Java where concurrency is acheived mainly via parallel code execution using threads</span>
            <aside class="notes">
              - The JavaScript engine runs inside an execution environment such as the Browser
                or Node.js<br><br>
              - This environment exposes many APIs to the JavaScript engine, such as the DOM
                 or XMLHttpRequest (browser) or the Timers (both)<br><br>
              - A main (single) thread pede para o runtime fazer uma dessas operações fornecendo
              uma função de callback. Do tipo: "quando alguém clicar aqui, corre esta função"<br><br>
              - Quando a operação é executada é colocada numa fila com a função de callback<br><br>
              - Em algu mommento, a mensagem sai da fila e é disparada a função de callback
            </aside>
          </section>

          <!--Event Loop-->
          <section data-transition="fade-in fade-out">
            <img src="images/el1.JPG" />
          </section>
          <section data-transition="fade-in fade-out">
            <img src="images/el2.JPG" />
          </section>
          <section data-transition="fade-in fade-out">
            <img src="images/el3.JPG" />
          </section>
          <section data-transition="fade-in fade-out">
            <img src="images/el4.JPG" />
          </section>
          <section data-transition="fade-in fade-out">
            <img src="images/el5.JPG" />
          </section>
          <section data-transition="fade-in fade-out">
            <img src="images/el6.JPG" />
          </section>
          <section data-transition="fade-in fade-out">
            <img src="images/el7.JPG" />
          </section>
          <section data-transition="fade-in fade-out">
            <img src="images/el8.JPG" />
          </section>
          <section data-transition="fade-in fade-out">
            <img src="images/el9.JPG" />
          </section>
          <section data-transition="fade-in fade-out">
            <img src="images/el10.JPG" />
          </section>
          <section data-transition="fade-in fade-out">
            <img src="images/el11.JPG" />
          </section>
          <section data-transition="fade-in fade-out">
            <img src="images/el12.JPG" />
          </section>
          <section data-transition="fade-in fade-out">
            <img src="images/el13.JPG" />
          </section>
          <section data-transition="fade-in fade-out">
            <img src="images/el14.JPG" />
          </section>
          <section data-transition="fade-in fade-out">
            <img src="images/el15.JPG" />
          </section>
          <section data-transition="fade-in fade-out">
            <img src="images/el16.JPG" />
          </section>
          <section data-transition="fade-in fade-out">
            <img src="images/el17.JPG" />
          </section>
          <section data-transition="fade-in fade-out">
            <img src="images/el18.JPG" />
          </section>
          <section data-transition="fade-in fade-out">
            <img src="images/el19.JPG" />
          </section>
          <section data-transition="fade-in fade-out">
            <img src="images/el20.JPG" />
          </section>
          <section data-transition="fade-in fade-out">
            <img src="images/el21.JPG" />
          </section>

          <!-- Support Material-->
          <section>
            <h5>Support Material</h5>
            <h3>Concurrency Model: Event Loop</h3>
            <ul>
              <li>
                <a href="https://www.youtube.com/watch?time_continue=1&v=8aGhZQkoFbQ" target="_blank">"What the heck is the event loop anyway?" (26min)</a> - Philip Roberts
              </li>
              <li>
                <a href="https://blog.carbonfive.com/2013/10/27/the-javascript-event-loop-explained/" target="_blank">The JavaScript Event Loop Explained</a> - Erin Swenson-Healey
              </li>
              <li>
                <a href="https://blog.avenuecode.com/understanding-the-javascript-concurrency-model" target="_blank">
                  Understanding the JavaScript Concurrency Model</a> - Rafael Bicalho
              </li>
            </ul>
          </section>

          <!--Back to Callback functions-->
          <!--Callback Hell-->
          <section>
            <h1>Callback Hell</h1>
            <a href="support_material/4_callback.js" target="_blank">Source code</a>
            <br>
            <img src="images/callbackception.jpg" />
          </section>

          <!--Promises-->
          <section>
          <h3>Promises</h3>
          <img src="images/promise.jpg" width="45%" height="45%" />
          </section>

          <!--Promises-->
          <section>
            <h3>Promises</h3>
            <ul>
              <li>Object that keeps track about whether a certain event has happened already or not</li>
              <li>An abstraction built on top of callbacks that gives us back functional composition and error bubbling in the async world</li>
              <li>A Promise object represents the eventual completion (or failure) of an asynchronous operation and its resulting value</li>
            </ul>
          </section>

          <!--Promises States-->
          <section>
            <h3>Promises States</h3>
            <img src="images/promise_states.JPG" style="border: 0px;" />
            <aside class="notes">
              A Promise has four states:<br><br>
              - <b>fulfilled:</b> Action related to the promise succeeded<br><br>
              - <b>rejected:</b> Action related to the promise failed<br><br>
              - <b>pending:</b> Promise is still pending i.e not fulfilled or rejected yet<br><br>
              - <b>settled:</b> Promise has fulfilled or rejected
            </aside>
          </section>

          <!--Promises-->
          <section>
            <h3>Promises</h3>
            <a href="support_material/5_promise.js" target="_blank">Example</a>
          </section>

          <!--Promises-->
          <section>
            <h3>Promises</h3>
            <ul>
              <li><span style="color: yellow;">Promise constructor</span> takes only <u>1 argument</u>, a <span style="color: yellow;">callback function</span></li>
              <li><span style="color: yellow;">Callback function</span> takes <u>2 arguments</u>, <span style="color: yellow;">resolve</span> and <span style="color: yellow;">reject</span></li>
              <li>Perform operations inside the callback function and if everything went well then call <span style="color: yellow;">resolve</span></li>
              <li>If desired operations do not go well then call <span style="color: yellow;">reject</span></li>
            </ul>
          </section>

          <!--Promises Consumers-->
          <section>
            <h3>Promises Consumers</h3>
            <ul>
              <li><span style="color: yellow;">.then()</span> is invoked when a promise is either resolved or rejected</li>
              <li><span style="color: yellow;">.catch()</span> is invoked when a promise is either rejected or some error has occured in execution</li>
            </ul>
            <img src="images/promise_hell.jpeg" />
            <aside class="notes">
            Existem mais comandos, como o <b>Promise.all()</b>: Parallel promises fulfills when all of the promises have fulfilled or
                                                                rejects as soon as one of the promises rejects<br>
                                                                It fulfills with an array of the values and rejects with the reason from the first 
                                                                promise that rejected
                                                                <br><br>
                                        o <b>Promise.race()</b>: It is possible to settle a promise as soon as one of many promises settles.
                                                                 Used when interested only in one of the results
            </aside>
          </section>

          <!--Async/Await-->
          <section>
            <h1>Async/Await</h1>
            <h5>ES8/2017 feature</h5>
            <img src="images/lord.jpeg" />
            <aside class="notes">
              - Permite escrever código assincrono num estilo sincrono.<br><br>
              - Foi desenhado para consumir Promises e não para as produzir.
            </aside>
          </section>

          <!--The Async & The Await-->
          <section>
            <h3>Async/Await</h3>
            <ul>
              <li>Abstraction <span style="color: yellow;">built on top of Promises</span> that allows writing asynchronous code in a readable and synchronous looking fashion</li>
              <li><span style="color: yellow;">async</span> functions always return a Promise!</li>
              <li><span style="color: yellow;">await</span> defers the execution of the remaining function code until the promise is fulfilled!</li>
            </ul>
            <aside class="notes">
              await só pode ser usado dentro de async functions
            </aside>
          </section>

          <!--Async/Await vs Promises-->
          <section style="width:100%;">
            <h5>Async/Await vs Promises</h5>
            <pre><code data-trim data-line-numbers contenteditable="true">
              function fetchUser(login) {
                const api = 'https://api.github.com/users';
                return fetch(`${api}/${login}`)
                  .then(response => response.json())
                  .then(user => ({
                    name: user.name,
                    location: user.location
                  }));
              }
            </code></pre>
            <pre><code data-trim data-line-numbers contenteditable="true">
              async function fetchUser(login) {
                const api = 'https://api.github.com/users';
                const response = await fetch(`${api}/${login}`
                const user = await response.json();
                return {
                  name: user.name,
                  location: user.location
                };
              }
            </code></pre>
            <span style="color: yellow;"><a href="support_material/6_async_await.js" target="_blank">Example</a></span>
          </section>

        </section>

        <!--ES6-->
        
        <section>
          <!--Intro-->
          <section>
            <h3>Next Generation JavaScript: <u>ES6/ES2015</u>, ES7/2016, ES8/2017...</h3>
            <img src="images/evo2.gif" style="border: 0px;" />
            <br>
            <span style="font-size: 20px;">ES: ECMA Script</span>
            <br>
            <span style="font-size: 20px;">ECMA: European Computer Manufacturers Association</span>
            <aside class="notes">
              - <b>ES6 é retro-compatível</b>
            </aside>
          </section>

          <!--ES6/2015-->
          <section>
            <h3>ES6/2015</h3>
            <ul style="font-size: 35px;">
              <li>Variable Declarations with <span style="color: yellow;">let</span> and <span style="color: yellow;">const</span></li>
              <li>Strings</li>
              <li>Arrow functions</li>
              <li>Destructuring</li>
              <li>Spread opreator</li>
              <li>Rest Parameters</li>
              <li>Classes and Subclasses</li>
            </ul>
          </section>

          <!--Let & Const-->
          <section>
            <h3>Let & Const</h3>
            <pre><code data-trim data-line-numbers contenteditable="true">
              // ES5
              var name5 = 'Lopes';
              var age5 = 30;
              name5 = 'Lopes da Silva';
              console.log(name5); // ?
            </code></pre>
            <pre><code data-trim data-line-numbers contenteditable="true">
              // ES6
              const name6 = 'Lopes';
              let age6 = 30;
              name6 = 'da Silva';
              console.log(name6); // ?
            </code></pre>
            <span style="font-size: 20px;">Block <span style="color: yellow;">{ }</span> scoped variable declaration</span>
            <pre><code data-trim data-line-numbers contenteditable="true">
              {
                var name5 = 'Lopes';
                let name6 = 'da Silva';
              }
              console.log(name5); // ?
              console.log(name6); // ?
            </code></pre>
            <aside class="notes">
              Substitui a utilização de var<br><br>
              <br><br>
              <b>Let:</b> let declarations attach to the block scope.
                          block scoped variables are not initialized until
                          they appear in the block<br><br>
              <b>Const:<b> Read-only block scoped variable declaration
              <br><br>
              <b>Resultados</b>
              - Lopes da Silva
              <br>
              - TypeError
              <br>
              Lopes e ReferenceError
            </aside>
          </section>

          <!--Strings-->
          <section>
            <h3>Strings: Template Literals</h3>
            <pre><code data-trim data-line-numbers contenteditable="true">
              // ES5
              var name5 = 'Brendan Eich';
              var jsYear5 = 1995;
              function calcAge5(yearOfBirth) {
                return new Date().getFullYear() - yearOfBirth;
              }

              console.log("My name is " + name5 + ". " +
                          "JS was born " + calcAge5(jsYear5) + " years ago.");
            </code></pre>
            <span style="font-size: 20px;">Template Literals <span style="color: yellow;">`Text ${variable_name_or_function}`</span></span>
            <pre><code data-trim data-line-numbers contenteditable="true">
              // ES6
              const name6 = 'Brendan Eich';
              const jsYear6 = 1995;
              function calcAge6(yearOfBirth) {
                return new Date().getFullYear() - yearOfBirth;
              }

              console.log(`My name is ${name6}. JS was born 
                          ${calcAge6(jsYear6)}years ago.`);
            </code></pre>
          </section>

          <!--Arrow Functions-->
          <section>
            <h3>Arrow Functions =></h3>
            <span style="font-size: 20px;">Shorter sintax</span>
            <pre><code data-trim data-line-numbers contenteditable="true">
              var math = {
                product: function(x, y) {
                  return x * y;
                  },
                square: function(x) {
                  return x * x;
                  }
              };
            </code></pre>
            <pre><code data-trim data-line-numbers contenteditable="true">
              // ES6
              let math = {
                product: (x, y) => x * y,
                square: x => x * x
              }
            </code></pre>
          </section>

          <!--Arrow Functions-->
          <section>
            <h3>Arrow Functions =></h3>
            <pre><code data-trim data-line-numbers contenteditable="true">
              // How can we fix this?
              let person = {
                name: 'Eusébio',
                greeting: `Hello ${name}!`,
                delayedHello(delay) {
                  setTimeout(function() {
                    console.log(this.greeting);
                  }, delay);
                }
              };
              person.delayedHello(1000); // undefined
            </code></pre>
            <span style="font-size: 20px;">Next slide has the solution. Old and new ways.</span>
          </section>

          <!--Arrow Functions-->
          <section>
            <h3>Arrow Functions =></h3>
            <span style="font-size: 20px;">Is a shortcut for creating anonymous functions with <span style="color: yellow;">this</span> bounded to lexical scope</span>
            <table>
              <tr>
                <td>
                  <pre style="width: 100%;"><code data-trim data-line-numbers contenteditable="true">
                    let person = {
                      name: "Eusébio",
                      greeting: `Hello ${name}!`,
                      delayedHello(delay) {
                        (function(greeting) {
                          setTimeout(function() {
                            console.log(greeting);
                          }, delay);
                        })(this.greeting);
                      }
                    };
                    
                    person.delayedHello(1000);
                    // Hello Eusébio!
                  </code></pre>
                </td>
                <td>
                  <pre style="width: 100%;"><code data-trim data-line-numbers contenteditable="true">
                    // ES6
                    let person = {
                      name: 'Eusébio',
                      greeting: `Hello ${name}!`,
                      delayedHello(delay) {
                        setTimeout(() => {
                          console.log(this.greeting);
                        }, delay);
                      }
                    };
                    person.delayedHello(1000);
                    // Hello Eusébio!
                  </code></pre>     
                </td>
              </tr>
            </table>
            <aside class="notes">
              Arrow Functions partilham o 'this' que já existe à volta
              <br><br>
              Isto significa que não são como as funções normais que têm o seu próprio 'this'.<br>
              As arrow functions não tem o seu próprio 'this', usam o 'this' das outer functions.
            </aside>
          </section>

          <!--Destructuring-->
          <section>
            <h3>Destructuring</h3>
            <ul>
              <li>Give us a convenient way to extract data from data stucture like an <span style="color: yellow;">object</span> or an <span style="color: yellow;">array</span></li>
              <li>Unpacks <span style="color: yellow;">selected values</span> from arrays, or <span style="color: yellow;">properties</span> from objects, into distinct variables</li>
            </ul>
          </section>

          <!--Destructuring-->
          <section>
              <h3>Destructuring</h3>
              <pre style="width: 100%;"><code data-trim data-line-numbers contenteditable="true">
                // ES5
                var arraio = ['Zé', 20];
                var name = arraio[0];
                var age5 = arraio[1];

                var obj6 = {
                  name: 'Zé',
                  age: 30
                };
                var name = obj6.name
              </code></pre> 
              <pre style="width: 100%;"><code data-trim data-line-numbers contenteditable="true">
                // ES6
                const arraio = ['Zé', 30];
                const [name, age] = arraio

                const obj = {
                  name: 'Zé',
                  age: 30
                };
                const { name } = obj;
              </code></pre>
              <aside class="notes">
                - Discarding non interesting properites form objects is easy
                  (por exemplo, não estamos a ir buscar a idade)
                <br><br>
                - os nomes convem que sejam os mesmos ou então ficam do tipo<br>
                  nome_da_prop: nome_pretendido
              </aside>
            </section>

            <!--Spread Operator-->
            <section>
              <h3>Spread Operator</h3>
              <ul>
                <li>When used in front of an array it will <span style="color: yellow;">spread out</span> into its <span style="color: yellow;">individual values</span></li>
                <li>A convenient way to expand elements of an <span style="color: yellow;">array</span> in places like <span style="color: yellow;">arguments</span> and <span style="color: yellow;">function calls</span></li>
              </ul>
              <pre style="width: 100%;"><code data-trim data-line-numbers contenteditable="true">
                const ages = [18, 30, 12, 21];
                function addFourAges(a, b, c, d) {
                  return a + b + c + d;
                }
                // ES 5
                const result1 = addFourAges(ages[0], ages[1], ages[2], ages[3]);
                console.log(result1);
                // ES 6
                const result2 = addFourAges(...ages);
                console.log(result2);
              </code></pre>
            </section>

          <!--Spread Operator-->
          <section>
            <h3>Rest Parameters</h3>
            <ul>
              <li>When used as a function argument, it will <span style="color: yellow;">gather the rest of the arguments</span> into an <span style="color: yellow;">array</span></li>
              <li>Allow to pass an arbitrary number of arguments into a function</li>
            </ul>
            <pre style="width: 100%;"><code data-trim data-line-numbers contenteditable="true">
              const ages = [18, 30, 12, 21];

              function addFourAges(name, ...ages) {
                console.log(name);
                return ages.reduce( (total, el) => {
                  return total + el;
                }, 0)
              }

              const result = addFourAges('Zé', ...ages);
              console.log(result);
            </code></pre>
          </section>

          <!--Classes-->
          <section>
            <h3>Classes</h3>
            <ul style="font-size: 25px;">
              <li>ES6 Classes are syntactic sugar over <span style="color: yellow;">prototype-based</span> inheritance</li>
              <li>Simply make it easier to implement inheritance and to create objects</li>
            </ul>
            <table>
              <tr>
                <td>
                  <pre style="width: 100%;"><code data-trim data-line-numbers contenteditable="true">
                    // ES5
                    // constructor function
                    function Person(name, age) {
                      this.name = name;
                      this.age = age;
                    }
                    // instance method
                    Person.prototype.getFakeAge = function(years
                      return this.age - years;
                    }
                    // static method
                    Person.greet = function() {
                      console.log('Hi!');
                    }
                  </code></pre>
                </td>
                <td>
                  <pre style="width: 100%;"><code data-trim data-line-numbers contenteditable="true">
                    // ES6
                    class Person {
                      constructor(name, age) {
                        this.name = name;
                        this.age = age;
                      }
                      fakeAge(years) {
                        return this.age - years;
                      }
                      static greet() {
                        console.log('Hi!');
                      }
                    }
                  </code></pre>
                  <aside class="notes">
                    - Utiliza a keyword <b>class</b><br><br>
                    - Utiliza o <b>constructor</b> como construtor para inicializar a classe<br><br>
                    - <b>static methods:</b> not inherited by the class instances
                  </aside>
                </td>
              </tr>
            </table>
          </section>

          <!--SubClassing-->
          <section>
            <h3>SubClassing</h3>
            <span style="font-size: 20px;">
              <span style="color: yellow;"><b>extends</b></span> keyword can be used to create a class as a child of another class
            </span>
            <pre style="width: 100%;"><code data-trim data-line-numbers contenteditable="true">
              class Animal {
                constructor(name) {
                  this.name = name;
                }
                speak() {
                  console.log(this.name + ' makes a noise.');
                }
              }
              
              class Dog extends Animal {
                speak() {
                  console.log(this.name + ' barks.');
                }
              }
            </code></pre>
          </section>

          <section>
            <h5>ES6/2015</h5>
            <h3>and more...</h3>
            <table style="font-size: 25px;">
              <tr>
                <td>
                  <ul>
                    <li>Constants</li>
                    <li>Scoping</li>
                    <li>Arrow Functions</li>
                    <li>Extended Parameter Handling</li>
                    <li>Template Literals</li>
                    <li>Extended Literals</li>
                    <li>Enhanced Regular Expression</li>
                    <li>Enhanced Object Properties</li>
                    <li>Destructuring Assignment</li>
                    <li>Modules</li>
                  </ul>
                </td>
                <td>
                  <ul>
                    <li>Classes</li>  
                    <li>Symbol Type</li>
                    <li>Generators</li>
                    <li>Map/Set/WeakMap/WeakSet</li>
                    <li>Typed Arrays</li>
                    <li>New Built-In Methods</li>
                    <li>Promises</li>
                    <li>Meta-Programming</li>
                    <li>Internationalization & Localization</li>
                  </ul>
                </td>
              </tr>
            </table>
            <img src="images/the_end.gif" style="border: 0px; width: 35%; height:35%;" />
          </section>

          <!--Last-->

          <section>
            <h3>References</h3>
            Some pictures and code from:
            <ul>
              <li><a href="https://www.udemy.com/the-complete-javascript-course/" target="_blank">The Complete JavaScript Course 2019: Build Real Projects!</a> (Jonas Schmedtmann)</li>
              <li><a href="https://github.com/getify/You-Dont-Know-JS" target="_blank">You don't know JS</a> (Kyle Simpson)</li>
              <li><a href="https://www.academiadecodigo.org/" targe="_blank">Academia de Código</a></li>
            </ul>
          </section>
        </section>        
        

      </div>
    </div>

    <script src="js/reveal.js"></script>

    <script>
      // More info about config & dependencies:
      // - https://github.com/hakimel/reveal.js#configuration
      // - https://github.com/hakimel/reveal.js#dependencies
      Reveal.initialize({
        dependencies: [
          { src: "plugin/markdown/marked.js" },
          { src: "plugin/markdown/markdown.js" },
          { src: "plugin/notes/notes.js", async: true },
          { src: "plugin/highlight/highlight.js", async: true }
        ]
      });
    </script>
    <!--
      https://eloquentjavascript.net/
      https://www.learn-js.org/
      http://javascript.info/
    -->
  </body>
</html>
